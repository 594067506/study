变量:变量声明:    var a int    var b float变量初始化：    var a int = 45 //声明并且初始化    var b = 6 //golang 会自动推到变量类型变量赋值：    var a int  //声明变量后 都会有一个初始值    a  = 10 //变量赋值程序中加号使用:    1.如果两边都是数值 那就做 加法运算    2.如果两边都是字符换那就是加法拼接    2.一边是数字一边是字符串 又怎么处理呢？go的数据类型：    基本数据类型      1.数值类型：        整数类型：            a. 无符号：int   int8    int16   int32   int64  //无符号            b. 有符号:uint  uint8    uint16  uint32  uint64  // 有符号        浮点数类型：            float32  float64      2.字符类型: 可用byte来存储      3.布尔型(bool)      4.字符串类型(string) golang 将string归为基本数据类型 注意字符和字符串的区别,golang中英文大小写或者数字使用ascii编码,中文是utf8编码    复杂数据类型：       1.指针(pointer)       2.数组       3.结构体(struct)       4.管道(channel)       5.函数(fun)       6.切片（slice）       7.接口（interface）       8.map第一周：多物理机部署部署和多容器部署在不同物理机rpc直链会节省网络开销一个微服务包括：kit库+通信协议(rpc/http)+其他三方库缺点：基础建设和技术复杂度高，如日志查询 单机的话 tail -f 就完事了基础设施的自动化微服务之间接口是面向资源，对外暴露的的是面向业务的接口如我们现在商城的首页接口微服务划分1.通过职能划分2.通过业务模块划分3.CQRS 如读写服务分离服务通信1.RPC 同步通信2.kafka异步通信grpc的 healthCheck 是client 和provider 之间的一个健康保障，服务发现也是为这两者提供检测的服务发现-Eureka 、etcd（https://blog.csdn.net/bbwangj/article/details/81092790） 阿里的Nacos1.客户端发现服务都像注册中心注册，客户端本地需要从注册中心获取到服务提供者的ip，然后在本地建立一个负载均衡连接(建议客户端发现模式,因为和去中心化的思想相同)2.服务端发现 服务都向注册中心注册,还有一个负载均衡中心(如nginx)，客户端不需要在本地建立负载均衡只需要把请求发送到slb或elb中心，由slb、elb来负责发出去这样的好处就是客户端不需要知道到底有多少个provider，坏处是，负载中心过于中心化etcd实现场景：1. 服务发现原理  在 使用 Raft 算法实现数据统一(设置etcd集群的时候使用)；  使用租约（Lease）实现对服务器的动态检测；  使用监测 (Watch) 实现对服务器变更的通知。结合上述三点 etcd 实现服务发现。2. 消息发布与订阅课下了解下zookeeper、四层/七层负载均衡多集群&多租户？了解订阅/发布模式第二周：1. 封装类(结构体) 要尽量少的暴露函数和变量，一般的思路就是    封装一个类，暴露一个New的方法返回类的指针，通过类方法类对结构体字段进行操作。参考errors.New()处理error思路： 一个错误只处理一次。减少业务代码中if err!=nil 的方法是封装数据校验：github.com/go-playground/validator/v10 protoc --proto_path=. --go_out=plugins=grpc,paths=source_relative:. test.proto./etcdctl put mykey "this is awesome"No help topic for 'put' # etcdctl 需要设置环境变量 ETCDCTL_API=3,使用第三版的api，默认的api是2[root@localhost etcd]# ETCDCTL_API=3 ./etcdctl put mykey "this is awesome"OK第三周：第一课：并发编程goroutine的一个生命周期： 任何启动的goroutine  我们都要能知道它什么时候结束，或者能在外面控制它结束 结束的标志：可以用可以在外面来接受一个停止信号来收到 外面控制结束：可以在启动goroutine的时候嵌入一个chan通过close这个chan来作为结束goroutine的标记 了解context包的用法(https://studygolang.com/articles/23247?fr=sidebar) 了解下kratos app启动和shutdown生命周期的管理第二课： 内存模型 了解：cpu和内存的调用机制 了解：cow-copy on write 了解 single machine  word 了解 MESI 第三课:package sync  go build -race /go text -race 来检测资源竞争  了解下sync/atomic  比较 sync/Mutex 性能 Mutex常见实现方式： 1.了解errorgroup和sync.pool第四周：工程化实践第一课：应用级别的项目目录api(对外暴露的接口)internal（内部业务实现）    models    dao    servicecmd：是对服务生命周期的一个管理，里面的main文件管理好服务怎么启动怎么关闭，怎么控制好服务的生命周期，不应该包含业务代码configs(一些配置项)go 会忽略编译 .or_开头的文件json:"-"` 表示不进行序列化，这种典型场景就是去用户信息的时候我们首先要冲mysql里面吧passward取出来第二课：api设计第四课 单元测试命名规范：1.项目创建tests目录存放各种测试用例2.测试用例文件名称必须以 _test.go结尾如 app_test.go该逻辑测试：1 .测试的方法必须以Test开后 如  TestUserInfo(t *testing.T)2. 执行命令  go test性能测试:4. 测试的方法必须以Benchmark开头如func BenchmarkBinarySearch(b *testing.B)  {	st:=learn.Stable{		Length: 5,		Array: []int{7,7,8,7,9},	}	for i:=0;i<b.N ;i++{		learn.BinarySearch(&st,8)	}}go test -bench=xxx（方法名）  例如  go test -bench=BinarySearch检查内存分配情况：go test -bench=BinarySearch -benchmem第五周:微服务的可用性设计第一课:隔离服务隔离:1. 服务划分等级，如账号服务=L0 商品服务=L0 这些基础服务 会做一些 负载均衡的冗余，并且是独占两台物理机2. 分销 拼团 H5资源活动的一些 不太重要的服务 会单独放在几台服务上kafka相关名词:Producer：生产者topic:主题partition: 分区，partition内部的数据是有序的，partition之间的数据是无序的Customer:消费者CustomerGroup:消费者组 统一个消费者的组的多个消费者消费的数据是不同的。多个消费者组 之间消费的数据是相同的(数据备份、冗余)之间的关系：一个topic 可以包含多个 partition一个Customer可以消费多个partition，但是一个partition 不能同时被多个Customer消费因此如果消费者比partition的数量要多，是没有意义的，多的消费者会空闲需要了解下 localcache快慢隔离:第二课：超时 目的是为了能尽可能行的存活1. 设定超时时间，超时会导致开启大量goroutine导致内存占满2. api定义的时候就要吧超时时间定义好，调用者在调用的时候根据文档社会超时时间3. 基础库设置超时策略 避免出现永不超时的问题， 如连接mysql redis 的时候4. 使用进程内的超时传递，用context超时来设置5. 注意连接超时、读超时、写超时第三课: 过载保护和限流1.令牌桶算法(golang/x/time/rate)2.漏桶算法(go.uber.org/ratelimit)这两种算法的阈值怎么设置 是比较难估算的http状态码429利特尔法则 ：变量:变量声明:    var a int    var b float变量初始化：    var a int = 45 //声明并且初始化    var b = 6 //golang 会自动推到变量类型变量赋值：    var a int  //声明变量后 都会有一个初始值    a  = 10 //变量赋值程序中加号使用:    1.如果两边都是数值 那就做 加法运算    2.如果两边都是字符换那就是加法拼接    2.一边是数字一边是字符串 又怎么处理呢？go的数据类型：    基本数据类型      1.数值类型：        整数类型：            a. 无符号：int   int8    int16   int32   int64  //无符号            b. 有符号:uint  uint8    uint16  uint32  uint64  // 有符号        浮点数类型：            float32  float64      2.字符类型: 可用byte来存储      3.布尔型(bool)      4.字符串类型(string) golang 将string归为基本数据类型 注意字符和字符串的区别,golang中英文大小写或者数字使用ascii编码,中文是utf8编码    复杂数据类型：       1.指针(pointer)       2.数组       3.结构体(struct)       4.管道(channel)       5.函数(fun)       6.切片（slice）       7.接口（interface）       8.mapgo训练营总结：https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/服务端架构学习：第一周：多物理机部署部署和多容器部署在不同物理机rpc直链会节省网络开销一个微服务包括：kit库+通信协议(rpc/http)+其他三方库缺点：基础建设和技术复杂度高，如日志查询 单机的话 tail -f 就完事了基础设施的自动化微服务之间接口是面向资源，对外暴露的的是面向业务的接口如我们现在商城的首页接口微服务划分1.通过职能划分2.通过业务模块划分3.CQRS 如读写服务分离服务通信1.RPC 同步通信2.kafka异步通信grpc的 healthCheck 是client 和provider 之间的一个健康保障，服务发现也是为这两者提供检测的服务发现-Eureka 、etcd（https://blog.csdn.net/bbwangj/article/details/81092790） 阿里的Nacos1.客户端发现服务都像注册中心注册，客户端本地需要从注册中心获取到服务提供者的ip，然后在本地建立一个负载均衡连接(建议客户端发现模式,因为和去中心化的思想相同)2.服务端发现 服务都向注册中心注册,还有一个负载均衡中心(如nginx)，客户端不需要在本地建立负载均衡只需要把请求发送到slb或elb中心，由slb、elb来负责发出去这样的好处就是客户端不需要知道到底有多少个provider，坏处是，负载中心过于中心化etcd实现场景：1. 服务发现原理  在 使用 Raft 算法实现数据统一(设置etcd集群的时候使用)；  使用租约（Lease）实现对服务器的动态检测；  使用监测 (Watch) 实现对服务器变更的通知。结合上述三点 etcd 实现服务发现。2. 消息发布与订阅课下了解下zookeeper、四层/七层负载均衡多集群&多租户？了解订阅/发布模式第二周：1. 封装类(结构体) 要尽量少的暴露函数和变量，一般的思路就是    封装一个类，暴露一个New的方法返回类的指针，通过类方法类对结构体字段进行操作。参考errors.New()处理error思路： 一个错误只处理一次。减少业务代码中if err!=nil 的方法是封装数据校验：github.com/go-playground/validator/v10 protoc --proto_path=. --go_out=plugins=grpc,paths=source_relative:. test.proto./etcdctl put mykey "this is awesome"No help topic for 'put' # etcdctl 需要设置环境变量 ETCDCTL_API=3,使用第三版的api，默认的api是2[root@localhost etcd]# ETCDCTL_API=3 ./etcdctl put mykey "this is awesome"OK第三周：第一课：并发编程goroutine的一个生命周期： 任何启动的goroutine  我们都要能知道它什么时候结束，或者能在外面控制它结束 结束的标志：可以用可以在外面来接受一个停止信号来收到 外面控制结束：可以在启动goroutine的时候嵌入一个chan通过close这个chan来作为结束goroutine的标记 了解context包的用法(https://studygolang.com/articles/23247?fr=sidebar) 了解下kratos app启动和shutdown生命周期的管理第二课： 内存模型 了解：cpu和内存的调用机制 了解：cow-copy on write 了解 single machine  word 了解 MESI 第三课:package sync  go build -race /go text -race 来检测资源竞争  了解下sync/atomic  比较 sync/Mutex 性能 Mutex常见实现方式： 1.了解errorgroup和sync.pool第四周：工程化实践第一课：应用级别的项目目录api(对外暴露的接口)internal（内部业务实现）    models    dao    servicecmd：是对服务生命周期的一个管理，里面的main文件管理好服务怎么启动怎么关闭，怎么控制好服务的生命周期，不应该包含业务代码configs(一些配置项)go 会忽略编译 .or_开头的文件json:"-"` 表示不进行序列化，这种典型场景就是去用户信息的时候我们首先要冲mysql里面吧passward取出来第二课：api设计第四课 单元测试命名规范：1.项目创建tests目录存放各种测试用例2.测试用例文件名称必须以 _test.go结尾如 app_test.go该逻辑测试：1 .测试的方法必须以Test开后 如  TestUserInfo(t *testing.T)2. 执行命令  go test性能测试:4. 测试的方法必须以Benchmark开头如func BenchmarkBinarySearch(b *testing.B)  {	st:=learn.Stable{		Length: 5,		Array: []int{7,7,8,7,9},	}	for i:=0;i<b.N ;i++{		learn.BinarySearch(&st,8)	}}go test -bench=xxx（方法名）  例如  go test -bench=BinarySearch检查内存分配情况：go test -bench=BinarySearch -benchmem第五周:微服务的可用性设计第一课:隔离服务隔离:1. 服务划分等级，如账号服务=L0 商品服务=L0 这些基础服务 会做一些 负载均衡的冗余，并且是独占两台物理机2. 分销 拼团 H5资源活动的一些 不太重要的服务 会单独放在几台服务上kafka相关名词:Producer：生产者topic:主题partition: 分区，partition内部的数据是有序的，partition之间的数据是无序的Customer:消费者CustomerGroup:消费者组 统一个消费者的组的多个消费者消费的数据是不同的。多个消费者组 之间消费的数据是相同的(数据备份、冗余)之间的关系：一个topic 可以包含多个 partition一个Customer可以消费多个partition，但是一个partition 不能同时被多个Customer消费因此如果消费者比partition的数量要多，是没有意义的，多的消费者会空闲需要了解下 localcache快慢隔离:第二课：超时 目的是为了能尽可能行的存活1. 设定超时时间，超时会导致开启大量goroutine导致内存占满2. api定义的时候就要吧超时时间定义好，调用者在调用的时候根据文档社会超时时间3. 基础库设置超时策略 避免出现永不超时的问题， 如连接mysql redis 的时候4. 使用进程内的超时传递，用context超时来设置5. 注意连接超时、读超时、写超时第三课: 过载保护和限流1.令牌桶算法(golang/x/time/rate)2.漏桶算法(go.uber.org/ratelimit)这两种算法的阈值怎么设置 是比较难估算的http状态码429利特尔法则 ：过载保护一个措施思想: 监控 CPU、内存、带宽指标 当指标达到80% 占用率以后开始触发过载保护(令牌桶算法、漏桶算法--这些算法都需要一个阈值) 然后 获取当前的qps 和前一段时间内qps的均值，若 当前的qps>前一段时间内qps的均值丢弃请求，否则放行过载保护一个措施思想:滑动均值: 监控 CPU、内存、带宽指标 当指标达到80% 占用率以后开始触发过载保护(令牌桶算法、漏桶算法--这些算法都需要一个阈值) 然后 获取当前的qps 和前一段时间内qps的均值，若 当前的qps>前一段时间内qps的均值丢弃请求，否则放行 限流算法:1.定时器算法，这个最简单,就是定义一个单位时间内的counter，当单位时间内qps>counter的时候拒绝访问        例如：一分钟内允许访问的最大数量为100 counter ==100,当qps<100则放行 >100返回 服务繁忙        2. 漏桶算法: 水(请求)先进入到漏桶里,漏桶以一定的速度出水(接口有响应速率),当水流入速度过大会直接溢出(访问频率超过接口响应速率),然后就拒绝请求,而当入小于出的情况下，漏桶不起任何作用。可以看出漏桶算法能强行限制数据的传输速率.                   这里的桶 就是一个 队列，当请求速度 <= 响应速度的时候，这个算法就是没用的，当请求速度>响应速度时 有部分请求会缓存在队列中，慢慢处理，超出队列的部分则丢弃        3. 令牌桶算法：以恒定的速率向桶(队列)中放入令牌,当桶中的令牌满了后会第四课：降级&重试我们可以在后台设置一个降级开关，当打开降级开关后前段和服务端都会执行一系列的降级操作以我们现在的商城举例前端：例如前端可以disable评论模块，推荐模块，尽量减少访问服务端的接口保证交易的正常进行服务端: 服务端也也是相同道理，当触发降级时，只保证交易服务的正常运行。 其他服务返回一些数据的缓存(可以每隔多久缓存一些缓存数据，如推荐数据、广告数据等)，或者暂时返回系统繁忙提示重试：当一个服务中 请求失败后,可以进行重试，但是一般来说请求不要超过三次，并且全局定义好错误吗，避免多层级服务连接的时候的重试风暴的出现第五课： 负载均衡负载均衡--权重轮训算法第六课：评论系统1. 发布评论、支持恢复楼层、楼中楼2. 一级可以删除自己的二级评论3. 评论排序按照时间、或者热度4. TO-b端的一些管理、如搜索删除变量:变量声明:    var a int    var b float变量初始化：    var a int = 45 //声明并且初始化    var b = 6 //golang 会自动推到变量类型变量赋值：    var a int  //声明变量后 都会有一个初始值    a  = 10 //变量赋值程序中加号使用:    1.如果两边都是数值 那就做 加法运算    2.如果两边都是字符换那就是加法拼接    2.一边是数字一边是字符串 又怎么处理呢？go的数据类型：    基本数据类型      1.数值类型：        整数类型：            a. 无符号：int   int8    int16   int32   int64  //无符号            b. 有符号:uint  uint8    uint16  uint32  uint64  // 有符号        浮点数类型：            float32  float64      2.字符类型: 可用byte来存储      3.布尔型(bool)      4.字符串类型(string) golang 将string归为基本数据类型 注意字符和字符串的区别,golang中英文大小写或者数字使用ascii编码,中文是utf8编码    复杂数据类型：       1.指针(pointer)       2.数组       3.结构体(struct)       4.管道(channel)       5.函数(fun)       6.切片（slice）       7.接口（interface）       8.map第一周：多物理机部署部署和多容器部署在不同物理机rpc直链会节省网络开销一个微服务包括：kit库+通信协议(rpc/http)+其他三方库缺点：基础建设和技术复杂度高，如日志查询 单机的话 tail -f 就完事了基础设施的自动化微服务之间接口是面向资源，对外暴露的的是面向业务的接口如我们现在商城的首页接口微服务划分1.通过职能划分2.通过业务模块划分3.CQRS 如读写服务分离服务通信1.RPC 同步通信2.kafka异步通信grpc的 healthCheck 是client 和provider 之间的一个健康保障，服务发现也是为这两者提供检测的服务发现-Eureka 、etcd（https://blog.csdn.net/bbwangj/article/details/81092790） 阿里的Nacos1.客户端发现服务都像注册中心注册，客户端本地需要从注册中心获取到服务提供者的ip，然后在本地建立一个负载均衡连接(建议客户端发现模式,因为和去中心化的思想相同)2.服务端发现 服务都向注册中心注册,还有一个负载均衡中心(如nginx)，客户端不需要在本地建立负载均衡只需要把请求发送到slb或elb中心，由slb、elb来负责发出去这样的好处就是客户端不需要知道到底有多少个provider，坏处是，负载中心过于中心化etcd实现场景：1. 服务发现原理  在 使用 Raft 算法实现数据统一(设置etcd集群的时候使用)；  使用租约（Lease）实现对服务器的动态检测；  使用监测 (Watch) 实现对服务器变更的通知。结合上述三点 etcd 实现服务发现。2. 消息发布与订阅课下了解下zookeeper、四层/七层负载均衡多集群&多租户？了解订阅/发布模式第二周：1. 封装类(结构体) 要尽量少的暴露函数和变量，一般的思路就是    封装一个类，暴露一个New的方法返回类的指针，通过类方法类对结构体字段进行操作。参考errors.New()处理error思路： 一个错误只处理一次。减少业务代码中if err!=nil 的方法是封装数据校验：github.com/go-playground/validator/v10 protoc --proto_path=. --go_out=plugins=grpc,paths=source_relative:. test.proto./etcdctl put mykey "this is awesome"No help topic for 'put' # etcdctl 需要设置环境变量 ETCDCTL_API=3,使用第三版的api，默认的api是2[root@localhost etcd]# ETCDCTL_API=3 ./etcdctl put mykey "this is awesome"OK第三周：第一课：并发编程goroutine的一个生命周期： 任何启动的goroutine  我们都要能知道它什么时候结束，或者能在外面控制它结束 结束的标志：可以用可以在外面来接受一个停止信号来收到 外面控制结束：可以在启动goroutine的时候嵌入一个chan通过close这个chan来作为结束goroutine的标记 了解context包的用法(https://studygolang.com/articles/23247?fr=sidebar) 了解下kratos app启动和shutdown生命周期的管理第二课： 内存模型 了解：cpu和内存的调用机制 了解：cow-copy on write 了解 single machine  word 了解 MESI 第三课:package sync  go build -race /go text -race 来检测资源竞争  了解下sync/atomic  比较 sync/Mutex 性能 Mutex常见实现方式： 1.了解errorgroup和sync.pool第四周：工程化实践第一课：应用级别的项目目录api(对外暴露的接口)internal（内部业务实现）    models    dao    servicecmd：是对服务生命周期的一个管理，里面的main文件管理好服务怎么启动怎么关闭，怎么控制好服务的生命周期，不应该包含业务代码configs(一些配置项)go 会忽略编译 .or_开头的文件json:"-"` 表示不进行序列化，这种典型场景就是去用户信息的时候我们首先要冲mysql里面吧passward取出来第二课：api设计第四课 单元测试命名规范：1.项目创建tests目录存放各种测试用例2.测试用例文件名称必须以 _test.go结尾如 app_test.go该逻辑测试：1 .测试的方法必须以Test开后 如  TestUserInfo(t *testing.T)2. 执行命令  go test性能测试:4. 测试的方法必须以Benchmark开头如func BenchmarkBinarySearch(b *testing.B)  {	st:=learn.Stable{		Length: 5,		Array: []int{7,7,8,7,9},	}	for i:=0;i<b.N ;i++{		learn.BinarySearch(&st,8)	}}go test -bench=xxx（方法名）  例如  go test -bench=BinarySearch检查内存分配情况：go test -bench=BinarySearch -benchmem第五周:微服务的可用性设计第一课:隔离服务隔离:1. 服务划分等级，如账号服务=L0 商品服务=L0 这些基础服务 会做一些 负载均衡的冗余，并且是独占两台物理机2. 分销 拼团 H5资源活动的一些 不太重要的服务 会单独放在几台服务上kafka相关名词:Producer：生产者topic:主题partition: 分区，partition内部的数据是有序的，partition之间的数据是无序的Customer:消费者CustomerGroup:消费者组 统一个消费者的组的多个消费者消费的数据是不同的。多个消费者组 之间消费的数据是相同的(数据备份、冗余)之间的关系：一个topic 可以包含多个 partition一个Customer可以消费多个partition，但是一个partition 不能同时被多个Customer消费因此如果消费者比partition的数量要多，是没有意义的，多的消费者会空闲需要了解下 localcache快慢隔离:第二课：超时 目的是为了能尽可能行的存活1. 设定超时时间，超时会导致开启大量goroutine导致内存占满2. api定义的时候就要吧超时时间定义好，调用者在调用的时候根据文档社会超时时间3. 基础库设置超时策略 避免出现永不超时的问题， 如连接mysql redis 的时候4. 使用进程内的超时传递，用context超时来设置5. 注意连接超时、读超时、写超时第三课: 过载保护和限流1.令牌桶算法(golang/x/time/rate)2.漏桶算法(go.uber.org/ratelimit)这两种算法的阈值怎么设置 是比较难估算的http状态码429利特尔法则 ：变量:变量声明:    var a int    var b float变量初始化：    var a int = 45 //声明并且初始化    var b = 6 //golang 会自动推到变量类型变量赋值：    var a int  //声明变量后 都会有一个初始值    a  = 10 //变量赋值程序中加号使用:    1.如果两边都是数值 那就做 加法运算    2.如果两边都是字符换那就是加法拼接    2.一边是数字一边是字符串 又怎么处理呢？go的数据类型：    基本数据类型      1.数值类型：        整数类型：            a. 无符号：int   int8    int16   int32   int64  //无符号            b. 有符号:uint  uint8    uint16  uint32  uint64  // 有符号        浮点数类型：            float32  float64      2.字符类型: 可用byte来存储      3.布尔型(bool)      4.字符串类型(string) golang 将string归为基本数据类型 注意字符和字符串的区别,golang中英文大小写或者数字使用ascii编码,中文是utf8编码    复杂数据类型：       1.指针(pointer)       2.数组       3.结构体(struct)       4.管道(channel)       5.函数(fun)       6.切片（slice）       7.接口（interface）       8.mapgo训练营总结：https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/服务端架构学习：第一周：多物理机部署部署和多容器部署在不同物理机rpc直链会节省网络开销一个微服务包括：kit库+通信协议(rpc/http)+其他三方库缺点：基础建设和技术复杂度高，如日志查询 单机的话 tail -f 就完事了基础设施的自动化微服务之间接口是面向资源，对外暴露的的是面向业务的接口如我们现在商城的首页接口微服务划分1.通过职能划分2.通过业务模块划分3.CQRS 如读写服务分离服务通信1.RPC 同步通信2.kafka异步通信grpc的 healthCheck 是client 和provider 之间的一个健康保障，服务发现也是为这两者提供检测的服务发现-Eureka 、etcd（https://blog.csdn.net/bbwangj/article/details/81092790） 阿里的Nacos1.客户端发现服务都像注册中心注册，客户端本地需要从注册中心获取到服务提供者的ip，然后在本地建立一个负载均衡连接(建议客户端发现模式,因为和去中心化的思想相同)2.服务端发现 服务都向注册中心注册,还有一个负载均衡中心(如nginx)，客户端不需要在本地建立负载均衡只需要把请求发送到slb或elb中心，由slb、elb来负责发出去这样的好处就是客户端不需要知道到底有多少个provider，坏处是，负载中心过于中心化etcd实现场景：1. 服务发现原理  在 使用 Raft 算法实现数据统一(设置etcd集群的时候使用)；  使用租约（Lease）实现对服务器的动态检测；  使用监测 (Watch) 实现对服务器变更的通知。结合上述三点 etcd 实现服务发现。2. 消息发布与订阅课下了解下zookeeper、四层/七层负载均衡多集群&多租户？了解订阅/发布模式第二周：1. 封装类(结构体) 要尽量少的暴露函数和变量，一般的思路就是    封装一个类，暴露一个New的方法返回类的指针，通过类方法类对结构体字段进行操作。参考errors.New()处理error思路： 一个错误只处理一次。减少业务代码中if err!=nil 的方法是封装数据校验：github.com/go-playground/validator/v10 protoc --proto_path=. --go_out=plugins=grpc,paths=source_relative:. test.proto./etcdctl put mykey "this is awesome"No help topic for 'put' # etcdctl 需要设置环境变量 ETCDCTL_API=3,使用第三版的api，默认的api是2[root@localhost etcd]# ETCDCTL_API=3 ./etcdctl put mykey "this is awesome"OK第三周：第一课：并发编程goroutine的一个生命周期： 任何启动的goroutine  我们都要能知道它什么时候结束，或者能在外面控制它结束 结束的标志：可以用可以在外面来接受一个停止信号来收到 外面控制结束：可以在启动goroutine的时候嵌入一个chan通过close这个chan来作为结束goroutine的标记 了解context包的用法(https://studygolang.com/articles/23247?fr=sidebar) 了解下kratos app启动和shutdown生命周期的管理第二课： 内存模型 了解：cpu和内存的调用机制 了解：cow-copy on write 了解 single machine  word 了解 MESI 第三课:package sync  go build -race /go text -race 来检测资源竞争  了解下sync/atomic  比较 sync/Mutex 性能 Mutex常见实现方式： 1.了解errorgroup和sync.pool第四周：工程化实践第一课：应用级别的项目目录api(对外暴露的接口)internal（内部业务实现）    models    dao    servicecmd：是对服务生命周期的一个管理，里面的main文件管理好服务怎么启动怎么关闭，怎么控制好服务的生命周期，不应该包含业务代码configs(一些配置项)go 会忽略编译 .or_开头的文件json:"-"` 表示不进行序列化，这种典型场景就是去用户信息的时候我们首先要冲mysql里面吧passward取出来第二课：api设计第四课 单元测试命名规范：1.项目创建tests目录存放各种测试用例2.测试用例文件名称必须以 _test.go结尾如 app_test.go该逻辑测试：1 .测试的方法必须以Test开后 如  TestUserInfo(t *testing.T)2. 执行命令  go test性能测试:4. 测试的方法必须以Benchmark开头如func BenchmarkBinarySearch(b *testing.B)  {	st:=learn.Stable{		Length: 5,		Array: []int{7,7,8,7,9},	}	for i:=0;i<b.N ;i++{		learn.BinarySearch(&st,8)	}}go test -bench=xxx（方法名）  例如  go test -bench=BinarySearch检查内存分配情况：go test -bench=BinarySearch -benchmem第五周:微服务的可用性设计第一课:隔离服务隔离:1. 服务划分等级，如账号服务=L0 商品服务=L0 这些基础服务 会做一些 负载均衡的冗余，并且是独占两台物理机2. 分销 拼团 H5资源活动的一些 不太重要的服务 会单独放在几台服务上kafka相关名词:Producer：生产者topic:主题partition: 分区，partition内部的数据是有序的，partition之间的数据是无序的Customer:消费者CustomerGroup:消费者组 统一个消费者的组的多个消费者消费的数据是不同的。多个消费者组 之间消费的数据是相同的(数据备份、冗余)之间的关系：一个topic 可以包含多个 partition一个Customer可以消费多个partition，但是一个partition 不能同时被多个Customer消费因此如果消费者比partition的数量要多，是没有意义的，多的消费者会空闲需要了解下 localcache快慢隔离:第二课：超时 目的是为了能尽可能行的存活1. 设定超时时间，超时会导致开启大量goroutine导致内存占满2. api定义的时候就要吧超时时间定义好，调用者在调用的时候根据文档社会超时时间3. 基础库设置超时策略 避免出现永不超时的问题， 如连接mysql redis 的时候4. 使用进程内的超时传递，用context超时来设置5. 注意连接超时、读超时、写超时第三课: 过载保护和限流1.令牌桶算法(golang/x/time/rate)2.漏桶算法(go.uber.org/ratelimit)这两种算法的阈值怎么设置 是比较难估算的http状态码429利特尔法则 ：过载保护一个措施思想: 监控 CPU、内存、带宽指标 当指标达到80% 占用率以后开始触发过载保护(令牌桶算法、漏桶算法--这些算法都需要一个阈值) 然后 获取当前的qps 和前一段时间内qps的均值，若 当前的qps>前一段时间内qps的均值丢弃请求，否则放行过载保护一个措施思想:滑动均值: 监控 CPU、内存、带宽指标 当指标达到80% 占用率以后开始触发过载保护(令牌桶算法、漏桶算法--这些算法都需要一个阈值) 然后 获取当前的qps 和前一段时间内qps的均值，若 当前的qps>前一段时间内qps的均值丢弃请求，否则放行 限流算法:1.定时器算法，这个最简单,就是定义一个单位时间内的counter，当单位时间内qps>counter的时候拒绝访问        例如：一分钟内允许访问的最大数量为100 counter ==100,当qps<100则放行 >100返回 服务繁忙        2. 漏桶算法: 水(请求)先进入到漏桶里,漏桶以一定的速度出水(接口有响应速率),当水流入速度过大会直接溢出(访问频率超过接口响应速率),然后就拒绝请求,而当入小于出的情况下，漏桶不起任何作用。可以看出漏桶算法能强行限制数据的传输速率.                   这里的桶 就是一个 队列，当请求速度 <= 响应速度的时候，这个算法就是没用的，当请求速度>响应速度时 有部分请求会缓存在队列中，慢慢处理，超出队列的部分则丢弃        3. 令牌桶算法：以恒定的速率向桶(队列)中放入令牌,当桶中的令牌满了后会第四课：降级&重试我们可以在后台设置一个降级开关，当打开降级开关后前段和服务端都会执行一系列的降级操作以我们现在的商城举例前端：例如前端可以disable评论模块，推荐模块，尽量减少访问服务端的接口保证交易的正常进行服务端: 服务端也也是相同道理，当触发降级时，只保证交易服务的正常运行。 其他服务返回一些数据的缓存(可以每隔多久缓存一些缓存数据，如推荐数据、广告数据等)，或者暂时返回系统繁忙提示重试：当一个服务中 请求失败后,可以进行重试，但是一般来说请求不要超过三次，并且全局定义好错误吗，避免多层级服务连接的时候的重试风暴的出现第五课： 负载均衡负载均衡--权重轮训算法第六课：评论系统1. 发布评论、支持恢复楼层、楼中楼2. 一级可以删除自己的二级评论3. 评论排序按照时间、或者热度4. TO-b端的一些管理、如搜索删除第七课：历史记录1.了解缓存写会的思路2.了解下hbase的优势在哪里3. kafka  如何控制一个用户的数据放在一个partition了解下 region sharding技术选型了解下 Elasticsearch: https://blog.csdn.net/makang110/article/details/80596017了解下 canal：订阅 mysql binlog了解下 进程内归并回源的包 golang.org/x/sync/singleflight令牌桶算法例子https://www.jianshu.com/p/4ce68a31a71d?utm_campaign=studygolang.com&utm_medium=studygolang.com&utm_source=studygolang.com第七课：分布式缓存memcache：val 要小于1Mredis 数据类型丰富  了解redisclient   redis Cluster  slot sharding热点缓存怎么解决 、缓存一致性怎么解决一致性哈希和 region sharding 求余 ,最完美的是一致性哈希
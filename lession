变量:变量声明:    var a int    var b float变量初始化：    var a int = 45 //声明并且初始化    var b = 6 //golang 会自动推到变量类型变量赋值：    var a int  //声明变量后 都会有一个初始值    a  = 10 //变量赋值程序中加号使用:    1.如果两边都是数值 那就做 加法运算    2.如果两边都是字符换那就是加法拼接    2.一边是数字一边是字符串 又怎么处理呢？go的数据类型：    基本数据类型      1.数值类型：        整数类型：            a. 无符号：int   int8    int16   int32   int64  //无符号            b. 有符号:uint  uint8    uint16  uint32  uint64  // 有符号        浮点数类型：            float32  float64      2.字符类型: 可用byte来存储      3.布尔型(bool)      4.字符串类型(string) golang 将string归为基本数据类型 注意字符和字符串的区别,golang中英文大小写或者数字使用ascii编码,中文是utf8编码    复杂数据类型：       1.指针(pointer)       2.数组       3.结构体(struct)       4.管道(channel)       5.函数(fun)       6.切片（slice）       7.接口（interface）       8.map第一周：多物理机部署部署和多容器部署在不同物理机rpc直链会节省网络开销一个微服务包括：kit库+通信协议(rpc/http)+其他三方库缺点：基础建设和技术复杂度高，如日志查询 单机的话 tail -f 就完事了基础设施的自动化微服务之间接口是面向资源，对外暴露的的是面向业务的接口如我们现在商城的首页接口微服务划分1.通过职能划分2.通过业务模块划分3.CQRS 如读写服务分离服务通信1.RPC 同步通信2.kafka异步通信grpc的 healthCheck 是client 和provider 之间的一个健康保障，服务发现也是为这两者提供检测的服务发现-Eureka 、etcd（https://blog.csdn.net/bbwangj/article/details/81092790） 阿里的Nacos1.客户端发现服务都像注册中心注册，客户端本地需要从注册中心获取到服务提供者的ip，然后在本地建立一个负载均衡连接(建议客户端发现模式,因为和去中心化的思想相同)2.服务端发现 服务都向注册中心注,还有一个负载均衡中心(如nginx)，客户端不需要在本地建立负载均衡只需要把请求发送到slb或elb中心，由slb、elb来负责发出去这样的好处就是客户端不需要知道到底有多少个provider，坏处是，负载中心过于中心化课下了解下zookeeper、四层/七层负载均衡多集群&多租户？了解订阅/发布模式第二周：1. 封装类(结构体) 要尽量少的暴露函数和变量，一般的思路就是    封装一个类，暴露一个New的方法返回类的指针，通过类方法类对结构体字段进行操作。参考errors.New()处理error思路： 一个错误只处理一次。减少业务代码中if err!=nil 的方法是封装